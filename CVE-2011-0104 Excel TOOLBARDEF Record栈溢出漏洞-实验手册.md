# CVE-2011-0104 Excel TOOLBARDEF Record栈溢出漏洞

## 实验目的

通过本实验，学习了如何通过动态调试定位栈溢出漏洞，理解了栈溢出漏洞的危害性与引发栈溢出漏洞的关键要素，使用基于污点追踪的动态调试定位关键代码的方法进行一次经典实践，为熟练掌握栈溢出漏洞的检测与防护奠定基础。

## 实验环境

  

| 项目名称         | 环境                   | 版本              | 备注                                                         |
| ---------------- | ---------------------- | ----------------- | ------------------------------------------------------------ |
| 操作系统（靶机） | Windows XP SP3         |                   | 简体中文版<br>之后简称其为XP                                 |
| 虚拟机           | VMware Workstation 17  | 17.6.1            |                                                              |
| 调试器           | OllyDebug              | 1.0.10.0          | 吾爱专用版（内置众多插件）<br>基于1.0.10改版<br/>之后简称其为OD |
| 调试器           | WinDbg（32位）         | 6.12.0002.633     |                                                              |
| 反汇编器         | IDA Pro                | 6.8               | 之后简称其为IDA或ida                                         |
| 漏洞软件         | Microsoft Office Excel | 2003（11.0.8211） | 中文版<br/>之后简称其为EXCEL或excel                          |



| 用户名        | 密码   |
| ------------- | ------ |
| xunguang      | 无     |
| Administrator | 123456 |



## 实验原理

栈溢出漏洞是一种最常见的缓冲区溢出漏洞，它发生在程序试图向固定长度的缓冲区写入过多数据时，超出的数据会覆盖相邻内存区域。若**精心构造**溢出的数据内容及溢出的长度，可以使得程序改变原本的栈结构与内容以改变程序的执行流程，使其跳转到包含恶意代码的内存区域

## 实验步骤

1. 进入`Windows XP SP3` 操作系统，登录 `xunguang` 用户名

2. 进入桌面，首先双击桌面的 `Excel 2003` 运行它，然后点击左下角的开始，然后选中 `WinDbg` 程序单击运行

   ![image-20241201163232875](.\img\image-20241201163232875.png)

3. 两个程序都打开运行后我们正式开始触发漏洞污点：

### 定位程序异常位置

#### 使用windbg附加调试我们刚才打开的excel2003进程

windbg程序中，单击左上角的`File`  => `Attach to a Process`

![image-20241201164409206](.\img\image-20241201164409206.png)

在弹出的列表中找到我们刚刚运行的`EXCEL.EXE`程序，选中它并点击OK

![image-20241201164642934](.\img\image-20241201164642934.png)

弹出的save提示选择No

![image-20241201164735957](.\img\image-20241201164735957.png)

然后，程序就会运行成这样：

![image-20241201164917766](.\img\image-20241201164917766.png)

我们在最下方的输入框中输入”g“，表示运行attach的excel进程，点击Enter

![image-20241201165134688](.\img\image-20241201165134688.png)

然后我们切到excel窗口，通过左上角的”文件“选择加载会触发漏洞的  `exploit.xlb` 文件（之后简称其为POC样本）

![image-20241201165459439](.\img\image-20241201165459439.png)

![image-20241201165713571](.\img\image-20241201165713571.png)

![image-20241201165747842](.\img\image-20241201165747842.png)

#### 查看异常信息

然后我们重新切换到windbg，发现windbg成功捕捉到了异常，异常出现在 EXECEL.EXE 本体文件中

![image-20241201170501450](.\img\image-20241201170501450.png)

这个异常表示在 0x30089ca1 这个地址，编译器读不出 0x51455047 这个地址，不知道这个地址代表什么。这是为什么呢？

> 一个正常的文件加载是不会出现这个异常的，那么为什么会出现这个异常呢，原因就是堆栈中的数据被覆盖了，原来可以读的地址被改成了 POC 样本中的数据导致不可读，0x51455047 这个数据极有可能是 POC 中的数据

我们来查看下当前栈区的数据情况（输入`kn` 然后enter）

![image-20241201171528656](.\img\image-20241201171528656.png)

![image-20241201171757913](.\img\image-20241201171757913.png)

记录下当前得到的信息

| 项目       | 地址           | 所在函数地址 | 调用处地址 |
| ---------- | -------------- | ------------ | ---------- |
| 异常触发点 | **0x30089CA1** | 未知         | 未知       |

然后点击windbg顶部的如下图所示的按钮（或shfit+F5）结束此次调试

![image-20241201173408152](.\img\image-20241201173408152.png)

仍然选择No，不保存

![image-20241201173440522](.\img\image-20241201173440522.png)



### 溯源污点链

#### 使用OD开始调试

点击桌面的文件夹快捷方式**”吾爱破解专用版Ollydbg“**，然后双击其中的**”吾爱破解[LCG].exe“**打开OD

![image-20241201173756403](.\img\image-20241201173756403.png)



我们使用OD调试excel（直接打开exe而不是附加进程）

![image-20241201184404808](.\img\image-20241201184404808.png)

![image-20241201184454576](.\img\image-20241201184454576.png)

选中 `EXCEL.EXE` 并点击打开

![image-20241201184556044](.\img\image-20241201184556044.png)

等待一段时间，加载完成后如下图

![image-20241201184721433](.\img\image-20241201184721433.png)

我们定位到上一步记录的异常触发点地址 **`0x30089CA1`** ，并对其下断点（光标移动到该行后按`F2`键或者鼠标双击该行地址）

![image-20241201185322165](.\img\image-20241201185322165.png)

下好断点后我们还要在excel窗口中加载会触发漏洞的POC样本（就像之前在windbg调试流程里所做的行为）

点击加载POC样本后OD应该会直接执行到断点处停下（若OD在POC加载后没有任何动静，尝试按 `F9` 键直接运行），查看断点是否设置成功（设置成功程序会执行到设置的断点处停下）

![image-20241201190337901](.\img\image-20241201190337901.png)

查看此时的栈区和寄存器区 的情况（通过寄存器去的ebp和esp来确定当前栈帧的区域）

![image-20241201190903439](.\img\image-20241201190903439.png)

可以看到，当前的栈帧的ebp已经被覆盖了，其内容指向一串不知道有什么用的ASCII字符串的地址

> 热知识；按照汇编函数调用规则来讲，ebp所指向的地址单元里存放的应该是当前栈帧的调用者栈帧的ebp地址

那么现在我们就应该来确定异常触发点所在的函数（我们之后可以将这个函数规记作 **`crashFunc`**）

现在我们有两种方式来确定**crashFunc**的地址

1. 通过IDA等静态分析手段来去确定**crashFunc**的地址。

   这种方式的好处是比较直观，坏处是很难一次性找出调用链条，而且在复杂场景下得到的结果不一定准确

2. 使用OD等动态调试的方式通过跟踪堆栈、分析堆栈数据来找出**crashFunc**的地址。

   这种方式的好处是得到的结果是准确的，而且技术上可以一次性找出调用链条，坏处是没静态分析工具那么直观

考虑到我们后续还要溯源污点链，因此这里采用动态调试的方式

#### 确认异常触发点的调用链

那么这里我们就需要OD调试时加载一个正常的（不会触发异常漏洞的）可以被excel打开的文件，我们可以随便新建一个空的xls文件用于打开

> 为什么要新建一个文件而不能使用原来的POC样本呢？
>
> 上面已经提到，加载POC样本时，excel关于**crashFunc**的栈帧已经发生了栈溢出，ebp已经被覆盖了，那么其ret返回地址也多半被覆盖了错误的地址，这样就无法根据已有的堆栈信息定位到真实的调用地址

此时我们在OD里选择 `调试` => `重新开始` （或者直接Ctrl+F2）重新载入excel.exe来调试

![image-20241201193523768](.\img\image-20241201193523768.png)

等待一会，待到OD窗口重新加载出内容后点击运行（或者按F9）

![image-20241201194226764](.\img\image-20241201194226764.png)

等到系统任务栏重新出现excel的进程，切换到excel窗口，然后载入正常的xls文件

![image-20241201194503467](.\img\image-20241201194503467.png)

切回OD窗口，可以看到此时OD运行到**0x30089CA1**地址的断点处停下了

![image-20241201194819418](.\img\image-20241201194819418.png)

我们来查看下此时正常的堆栈信息（注意ebp下方的值即当前栈帧的返回地址）

![image-20241201195220593](.\img\image-20241201195220593.png)

被圈出的这行的值就是 `call crashFunc` 完成之后，eip该指向的地址，其实OD的插件也已经给出了相关信息，而且插件也提示了 **`crashFunc`** 的地址是**0x30089B57**，我们可以验证下。

选择 ebp 下方的这一行，即**0x13AA8C**这行，选中后点击Enter，OD的反汇编窗口会跳转到地址为**0x3008A861**的地址处，可以查看此处的汇编代码，和我们分析的信息一致

![image-20241201200152402](.\img\image-20241201200152402.png)

![image-20241201200257394](.\img\image-20241201200257394.png)

然后我们在0x3008A85C处下个断点

OK，这里我们更新下得到的信息

| 项目       | 地址           | 所在函数地址                        | 调用处地址     |
| ---------- | -------------- | ----------------------------------- | -------------- |
| 异常触发点 | **0x30089CA1** | **0x30089B57**<br>（**crashFunc**） | **0x3008A85C** |

#### 分析栈溢出发生点

OD重新调试excel，让excel重新载入POC样本，流程和重新载入正常的xls文件流程相同，不过多赘述

载入POC样本确认后，OD执行到**0x3008A85C**处的断点

![image-20241201203757342](.\img\image-20241201203757342.png)

此时我们使用 `F7` 来单步步入，进入**crashFunc**函数中，然后持续F7直到栈帧空间开辟完成后，如下图

![image-20241201204233271](.\img\image-20241201204233271.png)

查看此时的堆栈窗口信息和寄存器窗口信息

![image-20241201204530403](.\img\image-20241201204530403.png)

![image-20241201204608933](.\img\image-20241201204608933.png)

可以观测到，此时的栈帧内还是正常的，但我们知道，在**crashFunc**的当前栈帧内等下会发生栈溢出破坏当前的栈帧

> 热知识：发生栈溢出破坏当前栈帧结果说明当前栈帧的区域的内存发生了写入行为

那么我们可以往当前的栈帧内存设置一个写入断点（即往栈空间写入数据时会发出中断暂停）

关键是我们该怎样操作呢？

由于栈帧内存设置一个写入断点需要在数据窗口中进行，因此我们需要把数据窗口展示的地址定位在当前栈帧地址附近，那么又该如何操作呢？

我们可以在栈区数据中找一个和当前栈帧esp或ebp相近的地址值，然后如下图操作

![image-20241201205640493](.\img\image-20241201205640493.png)

然后数据窗口就定位到**0x13AA28**附近了

![image-20241201205844765](.\img\image-20241201205844765.png)

然后我们选中当前esp地址（0x13AA28）处的数据，然后右键对此处下写入断点

![image-20241201210110690](.\img\image-20241201210110690.png)

下完断点后我们可以逐渐尝试F9运行，因为不确定当前栈帧自建立后到达栈溢出发生中间会有几次栈空间写入，并且也不清楚会在第几次写入发生栈溢出，所以每一次F9运行完成后我们都需要查看esp**特别是ebp及其附近**有没有被改写

第一次F9运行后，写入断点处发生了中断，esp变为了**0x13AA10**，ebp（**0x13AA88**）处附近未发生变化

![image-20241201210922778](.\img\image-20241201210922778.png)

数据区的0x13AA28往后（地址更大处）均未发生明显变化，遂继续F9观察

幸运的是，第二次的F9之后，寄存器窗口、数据窗口、堆栈窗口均发生了巨大变化

首先是寄存器窗口

![image-20241201211610420](.\img\image-20241201211610420.png)

esp和ebp同时发生了改变说明应当是**crashFunc**函数在运行时调用了其他子函数，这个子函数对栈空间有写行为，而且在写的过程中还至少写到了**0x13AA28**地址触发了写入断点（有缓冲区溢出乃至栈溢出的嫌疑，因为这个子函数的栈帧的ebp地址就是**0x13AA27**，按常理来说不应该触发**0x13AA28**地址的写入断点）

然后是数据窗口

![image-20241201212821275](.\img\image-20241201212821275.png)

明显发现0x13AA28处的数据发生了改变，但不知道改变了多少数据

然后查看堆栈窗口，由于已经知道0x13AA28处发生了数据覆写，那么我们就关注下crashFunc函数的栈帧的ebp处（0x13AA88）有没有被覆写

![image-20241201213147646](.\img\image-20241201213147646.png)

可以发现，0x13AA88处数据和其下方的ret数据没被覆写，但这并不能说明此次的写入断点触发是正常行为（我们刚才已经分析过为什么不正常），只能说明本次的写入断点触发并没有改写到crashFunc函数的栈帧的ebp处

于是查看反汇编区的代码

![image-20241201213829989](.\img\image-20241201213829989.png)

果然，当前执行的是一个串传送指令，而且使用了rep 这个循环执行命令，这个rep循环的次数和ecx有关，那么我们就要ecx是怎样来的以及其当前的值是多少给弄清楚，看一下附近的汇编代码和寄存器的当前值

![image-20241201214950493](.\img\image-20241201214950493.png)

根据附近的代码，可知，ecx当前值是eax的0x300赋值后再逻辑右移两位（相当于`[eax] / 4  =>  ecx`  ）0x300 / 4 = 0xC0

然后计算一下，从0x13AA27开始覆盖0xC0，会覆盖到0x13AAE7，很明显会将

crashFunc函数的栈帧的ebp处（0x13AA88）和crashFunc的返回地址给覆盖掉，明显发生了栈溢出

所以，我们也需要给当前这条 **`rep movs`** 指令（**0x3008942F**）下个断点

然后 F8 单步执行之后，执行到了这个断点的下一条指令，栈空间的写入已经结束，我们观察此时的数据窗口

![image-20241201220231160](.\img\image-20241201220231160.png)

很明显如我们分析的被覆盖了，那么这么大一段（0xC0长度）的数据从哪里来的呢？由于是打开POC样本文件发生的栈溢出，因此猜测这段数据来自POC文件中，于是使用16进制编辑器（WinHex）打开POC文件查看并根据0x13AA28处的16进制数据来搜索定位数据是否存在于POC文件中

![image-20241201220852424](.\img\image-20241201220852424.png)

查到了位置

![image-20241201221109710](.\img\image-20241201221109710.png)

对比发现数据一致，说明猜想正确，就是从文件中复制了数据到堆栈中

分析到了这里，我们已经知道excel本体程序中确实存在着栈溢出漏洞，而且位置大概是在**crashFunc**函数中调用的某个具有对栈区域写入性质的子函数

那么更新一下当前的已知信息

| 项目             | 地址           | 所在函数地址                        | 调用处地址     |
| ---------------- | -------------- | ----------------------------------- | -------------- |
| 异常触发点       | **0x30089CA1** | **0x30089B57**<br>（**crashFunc**） | **0x3008A85C** |
| 污点（溢出开始） | **0x3008942F** | 未知                                | 未知           |

#### 确认栈溢出点（污点）的调用链

OK，到现在为止，我们还需要知道污点所在函数地址和调用处地址，这部分内容的获取在之前的异常触发点也讲过如何通过追踪堆栈去做，那么这部分就不再细致分析了，大致说下流程就好

OD重新运行excel，流程省略，执行到**0x3008942F**地址的断点处

![image-20241201223732231](.\img\image-20241201223732231.png)

这里的堆栈信息提示了返回到**0x3070DEAA**，而栈帧所属的函数地址是**0x300893E7**

利用堆栈进行查找函数，验证下插件给出的信息并成功找到了污点函数的位置

![image-20241201224159522](.\img\image-20241201224159522.png)

OK，更新一下当前的已知信息

| 项目             | 地址           | 所在函数地址                        | 调用处地址     |
| ---------------- | -------------- | ----------------------------------- | -------------- |
| 异常触发点       | **0x30089CA1** | **0x30089B57**<br>（**crashFunc**） | **0x3008A85C** |
| 污点（溢出开始） | **0x3008942F** | **0x300893E7**                      | **0x3070DEA5** |

至于污点所在的函数到底是说明函数以及这个函数是怎样造成栈溢出漏洞的分析我们就放到静态反汇编分去完成，主要是这部分放到动态分析中完成的话，代价很大，因为函数变为汇编代码的过程会损失很多信息，而通过汇编代码恢复函数的这个过程如果给人脑分析就太过于繁琐，也容易出错，还是交给专业的反汇编软件来做比较好



### 反汇编追踪污点，定位问题函数

#### 使用IDA 32位打开excel.exe（本体程序）

![image-20241201225401738](.\img\image-20241201225401738.png)

就使用默认的PE打开，点击OK即可

![image-20241201225523076](.\img\image-20241201225523076.png)

然后提示要加载MSO.dll和excel.pdb等弹窗，选择取消或者No

![image-20241201225717159](.\img\image-20241201225717159.png)

然后

![image-20241201225818311](.\img\image-20241201225818311.png)

然后就是漫长的等待，等待加载完成

#### 污点调用链定位

 使用IDA 定位污点的调用处地址 **0x3070DEA5**

![image-20241201230813513](.\img\image-20241201230813513.png)

![image-20241201231101982](.\img\image-20241201231101982.png)

这个函数的地址也和我们收集的信息相符合，进入该函数看看

![image-20241201231420143](.\img\image-20241201231420143.png)

具体的污点处反汇编之后，发现是 **`qmemcpy`** 这个函数，该函数相当于 **`memcpy`**函数，只是会多一些内存对齐的功能

![image-20241201231533982](.\img\image-20241201231533982.png)

我们关注**`memcpy`**的函数原型

![image-20241202095914522](.\img\image-20241202095914522.png)

![image-20241202100018184](.\img\image-20241202100018184.png)

那么我们关注 **`qmemcpy`** 这个函数的参数，重点是第三个参数长度 `n` ，根据我们动态调试时的分析，这个参数（对应 `v7` ）实际是 0xC0（由0x300逻辑右移演变而来），那么我们就去追查这个 `v7` 从何而来

![image-20241202104555258](.\img\image-20241202104555258.png)

可以看到该函数的第三个参数 `a3` 可能作为**`qmemcpy`** 这个函数的参数 `n` ，我们回到父函数查看参数a3是怎样传进来的

![image-20241202105247594](.\img\image-20241202105247594.png)

可以看到，参数a3来自于函数 `sub_3008945F` 的返回值

进入函数 `sub_3008945F` 看下是在干什么，顺便看下返回值是怎么来的

![image-20241202110642520](.\img\image-20241202110642520.png)

那么使用OD动态调试验证这个result是否会返回0x300

找到 **0x3008945F** 这个函数，下断点，返回值为 eax，所以看看 eax 何时变为 0x300

![image-20241202112041549](.\img\image-20241202112041549.png)

经过多次运行（具体是在第6次运行到上面下的 `0x3008945F` 处的断点），当 运行到 `0x3008947C` 地址处（即完成了 `movzx eax, ……` 指令的运行后）发现 eax变为0x300 

![image-20241202113813200](.\img\image-20241202113813200.png)

在数据窗口找到0x300的来源

![image-20241202114654100](.\img\image-20241202114654100.png)

看到数据窗口里貌似有POC样本里的数据，怀疑这附近的整个部分都是从POC样本里读取的，大胆猜测整个0x300也是来自于POC样本，那么我们就在POC样本里查找 `00 30` 16进制数据，结果真的找到了，而且附近的数据一模一样 

![image-20241202115705459](.\img\image-20241202115705459.png)

好家伙，栈溢出漏洞为什么会出现 破案了，原来是给**`qmemcpy`**函数的参数 `n` （代表操作字节长度的那个参数）是直接从文件中读取的，没做过滤，导致攻击者可以复制任意长度（因为长度数据是从文件中读取）的任意数据（这部分数据也是来自于文件中）到栈空间，这不妥妥的标准栈溢出漏洞吗

OK，下面来张图总结下

![image-20241202120945273](.\img\image-20241202120945273.png)



## 实验总结

CVE-2011-0104 漏洞归根结底还是利用了不安全的函数 memcpy，而函数的两个参数一个是复制源数据的大小，一个是复制的地址都是从 POC 中读取的，竟然没有做任何的过滤，最后导致了栈溢出的发生，之后发布的补丁也是对这两个参数做了过滤处理

通过本次实验，我们深刻认识了栈溢出漏洞的危害，理解了栈溢出漏洞的原理，学会了如何通过污点定位的方法去查找栈溢出点进而找出污点调用链以及预防措施